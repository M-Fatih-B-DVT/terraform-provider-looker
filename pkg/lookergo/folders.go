package lookergo

import (
	"context"
	"fmt"
	"net/url"
	"time"
)

const FoldersBasePath = "4.0/folders"

type FoldersResource interface {
	List(context.Context, *ListOptions) ([]Folder, *Response, error)
	ListByName(context.Context, string, *ListOptions) ([]Folder, *Response, error)
	Get(context.Context, string) (*Folder, *Response, error)
	//Get(context.Context,*ListOptions, string) ([]Folder, *Response, error)
	Create(context.Context, *Folder) (*Folder, *Response, error)
	Update(context.Context, string, *Folder) (*Folder, *Response, error)
	Delete(context.Context, string) (*Response, error)
}

type FoldersResourceOp struct {
	client *Client
}

var _ FoldersResource = &FoldersResourceOp{}

type LookModel struct {
	Id    string `json:"id,omitempty"`
	Label string `json:"label,omitempty"`
}

type FolderBase struct {
	Name                 string           `json:"name"`                             // Unique Name
	ParentId             *string          `json:"parent_id,omitempty"`              // Id of Parent. If the parent id is null, this is a root-level entry
	Id                   *string          `json:"id,omitempty"`                     // Unique Id
	ContentMetadataId    *string          `json:"content_metadata_id,omitempty"`    // Id of content metadata
	CreatedAt            *time.Time       `json:"created_at,omitempty"`             // Time the folder was created
	CreatorId            *string          `json:"creator_id,omitempty"`             // User Id of Creator
	ChildCount           *int64           `json:"child_count,omitempty"`            // Children Count
	ExternalId           *string          `json:"external_id,omitempty"`            // Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
	IsEmbed              *bool            `json:"is_embed,omitempty"`               // Folder is an embed folder
	IsEmbedSharedRoot    *bool            `json:"is_embed_shared_root,omitempty"`   // Folder is the root embed shared folder
	IsEmbedUsersRoot     *bool            `json:"is_embed_users_root,omitempty"`    // Folder is the root embed users folder
	IsPersonal           *bool            `json:"is_personal,omitempty"`            // Folder is a user's personal folder
	IsPersonalDescendant *bool            `json:"is_personal_descendant,omitempty"` // Folder is descendant of a user's personal folder
	IsSharedRoot         *bool            `json:"is_shared_root,omitempty"`         // Folder is the root shared folder
	IsUsersRoot          *bool            `json:"is_users_root,omitempty"`          // Folder is the root user folder
	Can                  *map[string]bool `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
}

type DashboardBase struct {
	Can                *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	ContentFavoriteId  *string          `json:"content_favorite_id,omitempty"` // Content Favorite Id
	ContentMetadataId  *string          `json:"content_metadata_id,omitempty"` // Id of content metadata
	Description        *string          `json:"description,omitempty"`         // Description
	Hidden             *bool            `json:"hidden,omitempty"`              // Is Hidden
	Id                 *string          `json:"id,omitempty"`                  // Unique Id
	Model              *LookModel       `json:"model,omitempty"`
	QueryTimezone      *string          `json:"query_timezone,omitempty"`        // Timezone in which the Dashboard will run by default.
	Readonly           *bool            `json:"readonly,omitempty"`              // Is Read-only
	RefreshInterval    *string          `json:"refresh_interval,omitempty"`      // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
	RefreshIntervalToI *int64           `json:"refresh_interval_to_i,omitempty"` // Refresh Interval in milliseconds
	Folder             *FolderBase      `json:"folder,omitempty"`
	Title              *string          `json:"title,omitempty"`            // Dashboard Title
	UserId             *string          `json:"user_id,omitempty"`          // Id of User
	Slug               *string          `json:"slug,omitempty"`             // Content Metadata Slug
	PreferredViewer    *string          `json:"preferred_viewer,omitempty"` // The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
}

type Dashboard struct {
	ContentFavoriteId  string     `json:"content_favorite_id,omitempty"`
	ContentMetadataId  string     `json:"content_metadata_id,omitempty"`
	Description        string     `json:"description,omitempty"`
	Hidden             bool       `json:"hidden,omitempty"`
	Id                 string     `json:"id,omitempty"`
	Model              *LookModel `json:"model,omitempty"`
	QueryTimezone      string     `json:"query_timezone,omitempty"`
	Readonly           bool       `json:"readonly,omitempty"`
	RefreshInterval    string     `json:"refresh_interval,omitempty"`
	RefreshIntervalToI int64      `json:"refresh_interval_to_i,omitempty"`
	Folder             *Folder    `json:"folder,omitempty"`
	Title              string     `json:"title,omitempty"`
	UserId             string     `json:"user_id,omitempty"`
	Slug               string     `json:"slug,omitempty"`
	PreferredViewer    string     `json:"preferred_viewer,omitempty"`
}

type LookWithDashboards struct {
	Can                      *map[string]bool `json:"can,omitempty"`                        // Operations the current user is able to perform on this object
	ContentMetadataId        *string          `json:"content_metadata_id,omitempty"`        // Id of content metadata
	Id                       *string          `json:"id,omitempty"`                         // Unique Id
	Title                    *string          `json:"title,omitempty"`                      // Look Title
	UserId                   *string          `json:"user_id,omitempty"`                    // User Id
	ContentFavoriteId        *string          `json:"content_favorite_id,omitempty"`        // Content Favorite Id
	CreatedAt                *time.Time       `json:"created_at,omitempty"`                 // Time that the Look was created.
	Deleted                  *bool            `json:"deleted,omitempty"`                    // Whether or not a look is 'soft' deleted.
	DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                 // Time that the Look was deleted.
	DeleterId                *string          `json:"deleter_id,omitempty"`                 // Id of User that deleted the look.
	Description              *string          `json:"description,omitempty"`                // Description
	EmbedUrl                 *string          `json:"embed_url,omitempty"`                  // Embed Url
	ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`             // Excel File Url
	FavoriteCount            *int64           `json:"favorite_count,omitempty"`             // Number of times favorited
	GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"` // Google Spreadsheet Formula
	ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`            // Image Embed Url
	IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`             // auto-run query when Look viewed
	LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`           // Time that the Look was last accessed by any user
	LastUpdaterId            *string          `json:"last_updater_id,omitempty"`            // Id of User that last updated the look.
	LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`             // Time last viewed in the Looker web UI
	Model                    *LookModel       `json:"model,omitempty"`
	Public                   *bool            `json:"public,omitempty"`      // Is Public
	PublicSlug               *string          `json:"public_slug,omitempty"` // Public Slug
	PublicUrl                *string          `json:"public_url,omitempty"`  // Public Url
	QueryId                  *string          `json:"query_id,omitempty"`    // Query Id
	ShortUrl                 *string          `json:"short_url,omitempty"`   // Short Url
	Folder                   *FolderBase      `json:"folder,omitempty"`
	FolderId                 *string          `json:"folder_id,omitempty"`  // Folder Id
	UpdatedAt                *time.Time       `json:"updated_at,omitempty"` // Time that the Look was updated.
	ViewCount                *int64           `json:"view_count,omitempty"` // Number of times viewed in the Looker web UI
	Dashboards               *[]DashboardBase `json:"dashboards,omitempty"` // Dashboards
}

type Folder struct {
	Name                 string                `json:"name"`                             // Unique Name
	ParentId             *string               `json:"parent_id,omitempty"`              // Id of Parent. If the parent id is null, this is a root-level entry
	Id                   *string               `json:"id,omitempty"`                     // Unique Id
	ContentMetadataId    *string               `json:"content_metadata_id,omitempty"`    // Id of content metadata
	CreatedAt            *time.Time            `json:"created_at,omitempty"`             // Time the space was created
	CreatorId            *string               `json:"creator_id,omitempty"`             // User Id of Creator
	ChildCount           *int64                `json:"child_count,omitempty"`            // Children Count
	ExternalId           *string               `json:"external_id,omitempty"`            // Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
	IsEmbed              *bool                 `json:"is_embed,omitempty"`               // Folder is an embed folder
	IsEmbedSharedRoot    *bool                 `json:"is_embed_shared_root,omitempty"`   // Folder is the root embed shared folder
	IsEmbedUsersRoot     *bool                 `json:"is_embed_users_root,omitempty"`    // Folder is the root embed users folder
	IsPersonal           *bool                 `json:"is_personal,omitempty"`            // Folder is a user's personal folder
	IsPersonalDescendant *bool                 `json:"is_personal_descendant,omitempty"` // Folder is descendant of a user's personal folder
	IsSharedRoot         *bool                 `json:"is_shared_root,omitempty"`         // Folder is the root shared folder
	IsUsersRoot          *bool                 `json:"is_users_root,omitempty"`          // Folder is the root user folder
	Can                  *map[string]bool      `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
	Dashboards           *[]DashboardBase      `json:"dashboards,omitempty"`             // Dashboards
	Looks                *[]LookWithDashboards `json:"looks,omitempty"`                  // Looks
}

func (s *FoldersResourceOp) List(ctx context.Context, opt *ListOptions) ([]Folder, *Response, error) {
	return doList(ctx, s.client, FoldersBasePath, opt, new([]Folder))
}

func (s *FoldersResourceOp) ListByName(ctx context.Context, name string, opt *ListOptions) ([]Folder, *Response, error) {
	if name == "" {
		return nil, nil, NewArgError("name", "has to be non-empty")
	}
	qs := url.Values{}
	qs.Add("fields", "id,name,parent_id")
	qs.Add("name", name)

	path := fmt.Sprintf("%s/search", FoldersBasePath)

	return doListByX(ctx, s.client, path, opt, new([]Folder), qs)
}

func (s *FoldersResourceOp) Get(ctx context.Context, FolderId string) (*Folder, *Response, error) {
	return doGetById(ctx, s.client, FoldersBasePath, FolderId, new(Folder))
}

func (s *FoldersResourceOp) Create(ctx context.Context, requestFolder *Folder) (*Folder, *Response, error) {
	return doCreate(ctx, s.client, FoldersBasePath, requestFolder, new(Folder))
}

func (s *FoldersResourceOp) Update(ctx context.Context, FolderId string, requestFolder *Folder) (*Folder, *Response, error) {
	return doUpdate(ctx, s.client, FoldersBasePath, FolderId, requestFolder, new(Folder))
}

func (s *FoldersResourceOp) Delete(ctx context.Context, FolderId string) (*Response, error) {
	return doDelete(ctx, s.client, FoldersBasePath, FolderId)
}
